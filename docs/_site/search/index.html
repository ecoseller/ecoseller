<!DOCTYPE html>

<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Search | ecoseller</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="ecoseller e-commerce platform documentation" />
<meta property="og:description" content="ecoseller e-commerce platform documentation" />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="ecoseller" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Search" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"ecoseller e-commerce platform documentation","headline":"Search","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/siteicon.png"}},"url":"http://localhost:4000/search/"}</script>
<!-- End Jekyll SEO tag -->

	<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="ecoseller" />

	<link rel="stylesheet"
		href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="apple-touch-icon" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
	<link rel="icon" type="image/png" href="/images/favicon.ico">

	
</head>

<body>
	<header>
		<h1>
			<a style="color: black;" href="/"><img src="/images/emblem.svg"
					width="100" height="100" alt="ecoseller logo"></a>
			<a>ecoseller</a>
			<button type="button" class="open-nav" id="open-nav"></button>
		</h1>

		<form action="/search/" method="get">
			<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
			<input type="submit" value="Search" style="display: none;">
		</form>

		<nav class="full-navigation" >
			<ul>
				<li class="nav-item top-level ">
					
					<a href="/">Introduction</a>
				</li>
			</ul>

			<ul>
				
				
				<li class="nav-item top-level ">
					
					<a href="/administration/installation/">Administration documentation</a>
					<ul>
						
						<li class="nav-item "><a
								href="/administration/installation/">Installation</a></li>
						
						<li class="nav-item "><a
								href="/administration/administration/">Administration</a></li>
						
						<li class="nav-item "><a
								href="/administration/localization/">Localization</a></li>
						
						<li class="nav-item "><a
								href="/administration/authorization/">Authorization</a></li>
						
					</ul>
				</li>
				
				<li class="nav-item top-level ">
					
					<a href="/programming/technical-design/">Programming documentation</a>
					<ul>
						
						<li class="nav-item "><a
								href="/programming/technical-design/">Technical design</a></li>
						
						<li class="nav-item "><a
								href="/programming/backend/">Backend</a></li>
						
						<li class="nav-item "><a
								href="/programming/dashboard_storefront/">Dashboard and Storefront</a></li>
						
						<li class="nav-item "><a
								href="/programming/recommender_system/">Recommender system</a></li>
						
						<li class="nav-item "><a
								href="/programming/supportive_services/">Supportive services</a></li>
						
					</ul>
				</li>
				
				<li class="nav-item top-level ">
					
					<a href="/user/dashboard/">User category</a>
					<ul>
						
						<li class="nav-item "><a
								href="/user/dashboard/">User documentation - Dashboard</a></li>
						
						<li class="nav-item "><a
								href="/user/storefront/">User documentation - Storefront</a></li>
						
					</ul>
				</li>
				
			</ul>

			<ul>
				<li class="nav-item top-level ">
					
					<a href="/contribution/">Contribution</a>
				</li>
			</ul>
		</nav>
	</header>

	<section class="main">
		<div class="page-header">
			<h2>ecoseller</h2>
			<h3>Search</h3>
		</div>
		<article class="content">
			<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"administration-administration": {
						"id": "administration-administration",
						"title": "Administration",
						"category": "",
						"url": " /administration/administration/",
						"content": "Table of contents: Working with ecoseller REST API Authentication Obtaining a JWT Using a JWT API documentation User management Creating an initial admin user without dashboard Managing database Django &lt;-&gt; PostgreSQL connection Binding database to a local folder Running migrations Backing up database Restoring database Static files and media Implementing payment methods (PaymentAPI) Payment Gateway Integration Process PayBySquareMethod OnlinePaymentMethod Recommendations Connecting external services (NotificationAPI) Key Features of the ecoseller Notification API: Usage Configuring Notification API configuration TODO: Search engine Indexing products to Elasticsearch Automation with CRON job Turning off Elasticsearch Working with ecoseller REST API The ecoseller platform provides a comprehensive and powerful REST API that allows developers to interact with and extend the functionality of the e-commerce platform. This section of the documentation focuses on working with the ecoseller REST API and provides detailed guidance on utilizing its endpoints and authentication mechanisms. Please note that the ecoseller REST API was designed to be used primarily for dashboard purposes and is not intended to be used as a public API for the ecoseller platform. However, feel free to use it as you see fit. On the other hand, please consider using NotificationAPI for public API purposes and calling external services directly from ecoseller backend. Authentication Ecoseller’s REST API authentication relies on JSON Web Tokens (JWT) to secure and authorize API requests. JWT is a compact and self-contained token format that securely transmits information between parties using digitally signed tokens. In the context of ecoseller, JWTs are utilized to authenticate and authorize API access intended for dashboard. Obtaining a JWT To obtain a JWT, you need to send a POST request to the user login endpoint with the following payload: { \"email\": \"your_email\", \"password\": \"your_password\", \"dashboard_login\": true } If the provided credentials are valid, the API will return a response containing the JWT token: { \"access\": \"your_access_token\", \"refresh\": \"your_refresh_token\" } The access token is used to authenticate API requests, while the refresh token is used to obtain a new access token once the current one expires. The access token is valid for 5 minutes, while the refresh token is valid for 24 hours. To obtain a new access token, you need to send a POST request to the user refresh-token endpoint with the following payload: { \"refresh\": \"your_refresh_token\" } If the provided refresh token is valid, the API will return a response containing the new access token: { \"access\": \"your_new_access_token\" } Using a JWT Once you obtain a JWT, you need to include it in the Authorization header of your API requests. The header should have the following format: Authorization: JWT your_access_token API documentation The ecoseller backend provides a comprehensive API documentation that can be accessed by navigating to the api docs endpoint. This documentation is generated automatically using the drf-yasg package and provides detailed information about the available endpoints, their parameters, and the expected responses. Please make sure to use primairly dashboard endpoints since they’re designed to to modify data and require authentication. Storefront endpoints don’t. User management The user management functionality in ecoseller’s dashboard allows administrators to create and manage user accounts with various roles and permissions. This section of the administration documentation focuses on the process of creating a initial user in ecoseller using the Django Command-Line Interface (CLI). A admin is a special type of user account which has access to all administrative functions and controls within the ecoseller platform. Creating an initial admin user is an essential step in setting up your ecoseller administration panel, as it provides you with all privileges to manage and configure your e-commerce platform. All other admin users can be allways setup in the dashboard, but you need at least one user to be able to login to the dashboard. For more information about roles, permissions and users in general, please refer to Authorization section in admin. documentation. Creating an initial admin user without dashboard Creating an admin user without dashboard can be done through the Django CLI. To do so, run the following command: python3 manage.py createsuperuser Managing database Ecoseller utilizes a PostgreSQL database to store and manage data. This section of the documentation focuses on managing a PostgreSQL database within a Docker container and connecting it to a Django application. Django &lt;-&gt; PostgreSQL connection The Django application is configured to connect to a PostgreSQL database using the following environment variables: POSTGRES_DB=ecoseller POSTGRES_USER=postgres POSTGRES_PASSWORD=postgres POSTGRES_HOST=postgres_backend POSTGRES_PORT=5432 Binding database to a local folder To persist the data in the PostgreSQL container, you can bind a local folder on your host machine to the container’s data directory using Docker Compose. In your docker-compose.yml file, add the following volume configuration under the services section for the postgres_backend container: volumes: - . backend postgres data: var lib postgresql data This configuration ensures that the PostgreSQL data is stored in the . src backend postgres folder on your local machine. Running migrations It shouldn’t be neccessary to run migrations manually, but if you need to do so, you can run the following command: python3 manage.py makemigrations python3 manage.py migrate Backing up database It is crucial to regularly back up your PostgreSQL database to prevent data loss and ensure data integrity. Use the pg_dump utility to create a backup of the database. Run the following command to back up the database to a file: pg_dump -U your_username -d your_database_name -f path to backup.sql Replace your_username and your_database_name with the appropriate values. Specify the path where you want to save the backup file. Restoring database To restore a PostgreSQL database from a backup file, use the pg_restore utility. Run the following command to restore the database from a backup file: pg_restore -U your_username -d your_database_name path to backup.sql Replace your_username, your_database_name, and path to backup.sql with the appropriate values. Static files and media Ecoseller currently supports storing static and media files using local storage. While it does not natively integrate with object storage services like Amazon S3, it is possible to implement such functionality using the Python package s3boto3. Implementing payment methods (PaymentAPI) This guide will walk you through the process of extending the Core application with new payment methods without encountering conflicts with the existing codebase. By following the provided guidelines and leveraging the system’s flexible architecture, you’ll be able to seamlessly integrate various online payment gateways into your ecoseller ecommerce platform. Integrating online payment gateways into your ecommerce system offers numerous advantages. It allows your customers to securely make payments using their preferred payment methods, which can boost conversion rates and provide a seamless checkout experience. The ecoseller system’s architecture has been designed to make the implementation of new payment methods straightforward, enabling you to expand your payment gateway options as your business grows. Payment Gateway Integration Process To implement a new payment method within the ecoseller ecommerce system, you will need to follow these steps: Choose the appropriate base class: Your new payment method should inherit from either the PayBySquareMethod class or the OnlinePaymentMethod class. Both of these classes are derived from the BasePaymentMethod class and can be imported from core.api.payments.modules.BasePaymentMethod. Select the base class that aligns with the requirements of the payment gateway you are integrating. PayBySquareMethod is used in situations where it’s neccessary to provide user payment QR code. On the other hand OnlinePaymentMethod is used for generating link for third party payment gateway where is user usually redirected. Note that classes inherited from BasePaymentMethod obtain instance of Order model (see core.order.models) on initialization. So you can freely access data of Order and Cart. Create a new payment method class: In your codebase, create a new class that extends the chosen base class. Ideally put your code into separate file stored in core api payments modules. Provide a meaningful name for the class that reflects the payment gateway you are integrating. For example, if integrating the “XYZ Gateway,” you could name your class XYZGatewayMethod. Implement the necessary methods: PayBySquareMethod PayBySquareMethod is used to return Base64 encoded image and provide payment data such as IBAN, BIC, etc. In order to implement a payment method inherited from PayBySquareMethod you need to define two methods: pay - it’s expected that this method return a dictonary containing two required keys. qr_code - Base64 encoded image of the payment QR payment_data - dictionary containing payment information stored in text with keys such as amount, IBAN, payment_identification, etc. status - method returning PaymentStatus (core.api.payments.conf.PaymentStatus). So for example - calling API of your bank and checking icomming payments. OnlinePaymentMethod OnlinePaymentMethod is used to return payment link so that user can be redirected. In order to implement a payment method inherited from OnlinePaymentMethod you need to define two methods: pay - it’s expected that this method return a dictonary containing two required keys. payment_url - link to the payment gateway (usually provided by the payment gateway API with payment_id in it). payment_id - ID of the payment in the payment gateway status - method returning PaymentStatus (core.api.payments.conf.PaymentStatus). Usually implemented as a wrapper around payment gateway’s status getter. Examples: from .BasePaymentMethod import OnlinePaymentMethod, PayBySquareMethod from ..conf import PaymentStatus class TestGateway(OnlinePaymentMethod): def pay(self): return {\"payment_url\": \"https: payment.url\", \"payment_id\": \"1234567890\"} def status(self) -&gt; PaymentStatus: \"\"\" Moc status and return paid with some probability \"\"\" import random if random.random() &lt; 0.5: return PaymentStatus.PAID return PaymentStatus.PENDING class BankTransfer(PayBySquareMethod): def pay(self): self.bic = self.kwargs.get(\"bic\") self.iban = self.kwargs.get(\"iban\") self.currency = self.kwargs.get(\"currency\") self.variable_symbol = 123456789 self.amount = 100 return { \"qr_code\": \"base64 encoded image\", \"payment_data\": { \"amount\": self.amount, \"currency\": self.currency, \"variable_symbol\": self.variable_symbol, \"iban\": self.iban, \"bic\": self.bic, }, } def status(self) -&gt; PaymentStatus: \"\"\" Mock status and return paid with some probability \"\"\" import random if random.random() &lt; 0.5: return PaymentStatus.PAID return PaymentStatus.PENDING Registering payment method in the Core In order to let the Core know about your payment methods, you need to define JSON configuration file. This file can be stored anywhere within accessible space for the core. However, to keep ecoseller practices, we recommend to store this file in core config payments.json (default path). Your custom path must be stored in the PAYMENT_CONFIG_PATH environment variable. It’s a dictionary containing unique identifiers of payment methods. Those identifiers are up to you, the only requirement is that you keep the unique constraint and that the name makes somehow sense. You will use this name also in the dashboard to link the payment method with your backend implementation. Every payment method is required to have implementation key which is in the format {module}.{class}, so for example api.payments.modules.BankTransfer.BankTransfer or api.payments.modules.TestGateway.TestGateway. You can use optional key kwargs (keyword arguments) into which you can store everything constant that you want to access in the BasePaymentMethod implementation (it’s stored into self.kwargs variable 😉). Usually this is used to pass your IBAN, … into PayBySquareMethod or public key or path to public certificate into OnlinePaymentMethod . Example: { \"BANKTRANSFER_EUR\": { \"implementation\": \"api.payments.modules.BankTransfer.BankTransfer\", \"kwargs\": { \"currency\": \"EUR\", \"bankName\": \"Deutsche Bank\", \"accountNumber\": \"DE12500105170648489890\", \"swiftCode\": \"DEUTDEDBBER\" } }, \"BANKTRANSFER_CZK\": { \"implementation\": \"api.payments.modules.BankTransfer.BankTransfer\", \"kwargs\": { \"currency\": \"CZK\", \"bankName\": \"CŠOB\", \"accountNumber\": \"CZ5855000000001265098001\", \"swiftCode\": \"CEKOCZPP\" } }, \"TEST_API\": { \"implementation\": \"api.payments.modules.TestGateway.TestGateway\", \"kwargs\": { \"merchant\": \"123456\", \"secret\": \"1234567890abcdef1234567890abcdef\", \"url\": \"https: payments.comgate.cz v1.0 \" } } } Binding payment method to the implementation So you have your payment method implementation ready and want to bind to your payment method object. On the PaymentMethodCountry model is a field ready for this situation. There’re two ways to do it: Using dashboard: Navigate to the detail of payment method (Cart Payment Methods) in the dashboard, scroll to Country variants and set API Request for required country variant. Using direct database access: Find cart_paymentmethodcountry table in your database and set api_request field for the specific row the the value which you used as unique identifier of your payment method in the JSON config. So for example BANKTRANSFER_CZK. However direct database access is not recommended. Now you only need to process the data correctly on the storefront and you’re ready to go. So either redirect you user automatically, show the payment square or do something else. We tried to make it generic so that it’s not anyhow limiting for your specific use-case. Recommendations Because online payments are crucial part for customer’s safety and comfort, we recommend to use online payment gateways that are known to the users in specific country. For example, don’t use czech payment gateway for german customers and vice-versa. Use something that your customers know and are familiar with. Due to that we decided that we will allow to bind payment method implementation to every country variant. Connecting external services (NotificationAPI) This comprehensive guide will provide you with all the necessary information to seamlessly extend ecoseller’s functionality by leveraging external APIs. With the Notification API, you can effortlessly integrate your own systems and services to respond to specific events within the ecoseller platform, such as product save, order save, and more. The ecoseller Notification API empowers you to enhance your ecoseller experience by enabling real-time communication and synchronization with external applications. By leveraging this API, you can ensure that your external systems stay up to date with the latest changes and events happening within ecoseller, allowing for a seamless and efficient workflow. This documentation will walk you through the entire process of integrating the Notification API into your application. You’ll learn how to configure endpoints and interpret the data sent by ecoseller. Key Features of the ecoseller Notification API: Event-based Triggers: The notifications API allows you to define specific events within ecoseller, such as PRODUCT_SAVE and ORDER_SAVE. These events serve as triggers for the notifications. Multiple Notification Types: The API supports various notification types, including RECOMMENDERAPI, HTTP, and EMAIL. You can choose the appropriate type based on your integration requirements. Flexible Methods: Each notification type can have different methods associated with it. For example, for the RECOMMENDERAPI type, the method store_object is used, while for the HTTP type, methods like POST are utilized. HTTP Integration: The API allows you to send HTTP requests to external endpoints by specifying the URL. This enables seamless integration with other systems or services that can receive and process the notifications. Email Notifications: With the “EMAIL” type, you can send email notifications related to specific events. In the given configuration file, the “send_order_confirmation” method is used to trigger the sending of an order confirmation email. Customization: The JSON configuration file provides flexibility for customization. You can easily add or modify notification types, methods, and URLs based on your specific integration requirements. Expandable Event List: The JSON configuration can be extended to include additional events and corresponding notifications. This allows you to adapt the API to match a wide range of events and actions within the ecoseller platform. By leveraging these key features of the notifications API, you can extend the functionality of ecoseller by seamlessly integrating with external systems, such as recommender engines, HTTP-based APIs, and email services. This enables you to create powerful workflows and automate processes based on specific events occurring within ecoseller. Usage Here is some example (default) NotificationAPI configuration. Configuring Notification API configuration To configure your notifications, you need to edit provided JSON configurations in the Core component. The provided configuration might look like this: { \"PRODUCT_SAVE\": [ { \"type\": \"RECOMMENDERAPI\", \"method\": \"store_object\" }, { \"type\": \"HTTP\", \"method\": \"POST\", \"url\": \"http: example.com api product\" } ], \"ORDER_SAVE\": [ { \"type\": \"HTTP\", \"method\": \"POST\", \"url\": \"http: example.com api order\" }, { \"type\": \"EMAIL\", \"method\": \"send_order_confirmation\" } ] } As you can see, for every trigger you can setup list of events that will be performed. There are multiple actions you can perform: HTTP type: this action requires to have method and url provided. As the title says, method is mean as an HTTP Method. You can use all methods utilized by Python requests module. EMAIL type: you can control sending e-mails using internal email app. Feel free to remove e-mail events that you don’t want to be sent using the Django interface. RECOMMENDER type: if you don’t want to use provided recommendation system feature, feel free to remove events providing data to the recommender. We recommend to edit configuration JSON directly (core config notifications.json). However, you can define your custom one and installing it by setting NOTIFICATIONS_CONFIG_PATH as your environment variable. TODO: * List of triggers Search engine ecoseller incorporates Elasticsearch as a component of its technology stack. Elasticsearch is a powerful search engine that enables ecoseller to deliver fast and accurate search results. Indexing products to Elasticsearch To ensure efficient product searches and recommendations within Ecoseller, it is crucial to index your products in Elasticsearch. Ecoseller provides a convenient CLI command within the backend container to perform this indexing process. To index your products using the CLI command, follow these steps: Access the backend container: If you are running ecoseller locally using Docker, open your terminal and navigate to the Ecoseller project directory. Use the following command to access the backend container: docker exec -it &lt;your_backend_container_id_or_name&gt; bin bash Run the indexing command: Once inside the backend container, run the following command to index the products in Elasticsearch: python3 manage.py search_index --rebuild This command triggers the indexing process, where the products will be parsed, analyzed, and stored in Elasticsearch for efficient searching and recommendation functionalities. Note: Ensure that you are in the correct directory within the backend container (usually the project’s root directory) before executing the command. The indexing process may take some time, depending on the size of your product database. Once the process is complete, your products will be fully indexed and ready for efficient searching and recommendation generation within Ecoseller. Automation with CRON job You can also automate the indexing process by scheduling a CRON job to run the indexing command at specified intervals. This ensures that your Elasticsearch index stays up to date with any changes in your product database. Set up a CRON job with the following command: 0 2 * * * docker exec &lt;your_backend_container_id_or_name&gt; python3 manage.py search_index --rebuild Turning off Elasticsearch If you no longer wish to use Elasticsearch in your Ecoseller setup, you can easily disable it by adjusting the environment variables and stopping the Elasticsearch container. Follow the steps below to turn off Elasticsearch: Update environment variables: (please see dedicated section for environment variables in the installation guide) Set the USE_ELASTIC variable to 0 in the backend env file. Stop the Elasticsearch container Restart the backend container With these steps completed, Elasticsearch will be disabled in your Ecoseller setup. However, please note that this will also disable the fast search functionality within Ecoseller. Therefore, it is recommended to keep Elasticsearch enabled for user experience."
					}

					
				
			
		
			
				
					,
					

					"administration-authorization": {
						"id": "administration-authorization",
						"title": "Authorization",
						"category": "",
						"url": " /administration/authorization/",
						"content": "Table of contents: Backend Frontend Hiding components Disabling components To achieve better security, ecoseller introduces so-called Roles. Each role has a set of permissions. Permissions are used to restrict access to certain parts of the application. For future use, ecoseller creates a new permission (more precisely four for each action - add change view delete) for each model. At this moment, ecoseller is actively using the following permissions: - add role | group_add_permission - change role | group_change_permission - can change cart | cart_change_permission - add category | category_add_permission - change category | category_change_permission - add page (cms) | page_add_permission - change page (cms) | page_change_permission - change product price | productprice_change_permission - add product price | productprice_add_permission - add product media | productmedia_add_permission - change product media | productmedia_change_permission - add product type | producttype_add_permission - change product type | producttype_change_permission - add product | product_add_permission - change product | product_change_permission - add user | user_add_permission - change user | user_change_permission - add price list | pricelist_add_permission - change price list | pricelist_change_permission - add attribute type | attributetype_add_permission - change attribute type | attributetype_change_permission - add base attribute | baseattribute_add_permission - change base attribute | baseattribute_change_permission Ecoseller also comes with three predefined roles with the following permissions: Editor permissions: -can change cart -can change product price -can add product price -can change product media -can add product media -can change product -can add product -can change category -can add category -can change page (cms) -can add page (cms) -can add product type -can change product type -can add price list -can change price list -can add attribute type -can change attribute type -can add base attribute -can change base attribute UserManager permissions: -can add user -can change user -can add group -can change group Copywriter permissions: -can change page (cms) -can change product -can change product media -can change category Ecoseller also comes with a predefined admin role that has all permissions. To allow users to specify new roles on deployment, we created a special config defined in backend core roles config roles.json (with predefined roles mentioned above) file with the following structure: [ { \"Role1\" : { \"permissions\" : [ { \"name\" : \"Permission1\", \"description\" : \"Permission1 description\" \"type\" : \"ADD\", \"model\" : \"Model1\" }, { \"name\" : \"Permission2\", \"description\" : \"Permission2 description\", \"type\" : \"CHANGE\", \"model\" : \"Model1\" }, { \"name\" : \"Permission3\", \"description\" : \"Permission3 description\", \"type\" : \"DELETE\", \"model\" : \"Model2\" } ], \"decription\" : \"Description of Role1\", \"name\" : \"Role1Name\" } }, { \"Role2\" :{ \"permissions\" : [ { \"name\" : \"Permission4\", \"description\" : \"Permission4 description\", \"type\" : \"VIEW\", \"model\" : \"Model1\" }, { \"name\" : \"Permission5\", \"description\" : \"Permission5 description\" \"type\" : \"DELETE\", \"model\" : \"Model3\" }, { \"name\" : \"Permission6\", \"description\" : \"Permission6 description\", \"type\" : \"CHANGE\", \"model\" : \"Model3\" }, { \"name\" : \"Permission1\", \"description\" : \"Permission1 description\" \"type\" : \"ADD\", \"model\" : \"Model1\" } ] \"description\" : \"Description of Role2\", \"name\" : \"Role2Name\" } } ] Each role has a unique name, description and a list of permissions. Each permission has a unique name, description, type and model. The type can be one of the following: ADD, CHANGE, VIEW, DELETE. The model is the name of the model to which the permission is assigned. The name of the model is the same as the name of the model in the database. For example, the name of the model for the Product model is product. The name of the model for the ProductPrice model is productprice. Each role and its corresponding permissions are created once the system is deployed during a migration process. A description of the whole workflow with permissions (e.g. creating a new role, assigning it to specific users) can be found in the Users &amp; Roles section. To ensure maximum security, the way roles affect workflow differs between the frontend and the backend. The following sections describe how. Backend The backend uses decorators to restrict access to certain endpoints. Each endpoint has a corresponding decorator that checks if the user has the required permission. If the user does not have the required permission, the decorator returns a 403 response. More information about decorators can be found in the Programming documentation. Frontend The frontend uses context providers to hide show or enable disable certain components based on the user’s permissions.Some components have a corresponding permission that is checked before the component is rendered. If the user does not have the required permission, the component is not rendered or is disabled. More information about context providers can be found in the Programming documentation. Hiding components In the dashboard, we have a sidebar with links to various parts of the system. Some links have a corresponding permission that is checked before the link is rendered. If the user does not have the required permission, the link is not rendered. Currently restricted links and their corresponding permissions are: Products - product_change_permission - product_add_permission Categories - category_change_permission - category_add_permission CMS - page_change_permission - page_add_permission Users &amp; Roles - user_change_permission - user_add_permission - group_change_permission - group_add_permission Disabling components We restricted disabling to specific actions - e.g. button click or dragging component. Some components have corresponding permissions that are checked before the component itself is enabled. If the user does not have the required permission, the components are disabled, preventing the user to trigger further action. Some of the currently restricted actions and their corresponding permissions are: Adding new category - category_add_permission Adding Dragging media components - productmedia_change_permission Creating role - group_add_permission Editing user general information - user_change_permission"
					}

					
				
			
		
			
				
					,
					

					"administration-installation": {
						"id": "administration-installation",
						"title": "Installation",
						"category": "",
						"url": " /administration/installation/",
						"content": "Table of contents: Prerequisites Running ecoseller Development environment Production environment Reverse proxy Demo environment Environment variables Backend Example Recommendation system Example Reserved ports Prerequisites Before proceeding with the installation of ecoseller, it is important to ensure that your machine meets the necessary prerequisites. While ecoseller itself is not demanding and can run on less powerful devices, it is recommended to have a slightly more capable setup for the default installation, especially when including the Elasticsearch and AI recommendation system. To run ecoseller with the AI recommendation system and Elasticsearch, we recommend using a machine with the following specifications: CPU: 8 cores or more RAM: 8GB or more Free Space: 10GB It’s worth noting that Elasticsearch itself requires a significant amount of memory to run efficiently, ideally around 4GB. Therefore, the suggested 8GB RAM allocation ensures smooth operation of both ecoseller and Elasticsearch. However, if you are running ecoseller without the Elasticsearch and AI recommendation system or with a smaller dataset, you can use less powerful devices as well. Based on our testing, we have observed that for a typical scenario with 2100 product variants and several thousand events, the training process for Level 3 recommendations requires a maximum of 1GB of RAM and completes within approximately 2 seconds. For Level 2 recommendations, the memory consumption is around 130MB, and the training process takes approximately 92 seconds. By considering these prerequisites and performance benchmarks, you can ensure optimal performance and resource allocation for ecoseller and its AI recommendation system. Since ecoseller is fully containerized, make sure your system is Docker-ready before proceeding with the installation. If you are new to Docker, you can refer to the official Docker documentation for detailed instructions on installing Docker on your machine. Also you should have some experience with Docker Compose, Django, Python and Next.js (React). If not - you can learn it from the official documentations. If you don’t have time for that - you can hire us to do it for you (the way it was meant to without compromises). 😉 Running ecoseller ecoseller can be deployed in different environments depending on your needs, whether it’s for development, production, or a demo environment. This section will guide you through the steps to run Ecoseller in each of these environments. The starting point, however, is the same for all environments. You need to clone the ecoseller repository from the source code repository and navigate to the project directory in your terminal. git clone https: github.com ecoseller ecoseller.git Development environment To run ecoseller in a development environment, follow these steps: Ensure you have Docker and Docker Compose installed on your system. Clone the Ecoseller repository from the source code repository. Navigate to the project directory in your terminal. Create src backend docker-compose.env from example. Please make sure DEBUG flag is set to 1 and DJANGO_ALLOWED_HOSTS is set to \"*\" in this file. Create src recommender_system docker-compose.env from example. Run the following command to start ecoseller in development mode: docker compose up. This command will start all the containers and services required for ecoseller to run. All the containers will be started in the foreground, and you will be able to see the logs from each container in your terminal. Please note that the first time you run this command, it will take some time to download the required images and build the containers. Also note that both storefront and dashboard are quite slow in the developement mode since they are running in the debug mode and Next.js rebuilds every single page on every single request. Production environment In a production environment, Ecoseller utilizes a combination of Gunicorn for both Flask Recommender and Django backend, and Nginx to ensure a robust and efficient deployment. The production build mode of Next.js is used to run the storefront and dashboard services. Additionally, Nginx is configured as a reverse proxy to efficiently handle incoming requests and distribute them to the appropriate services. Reverse proxy Nginx is used as a reverse proxy to efficiently handle incoming requests and distribute them to the appropriate services. It acts as a middle layer between the client and the backend services, enhancing performance and enabling load balancing. Two configurations are supplied for the Nginx reverse proxy: Simple Port Mapping: In this configuration, Nginx maps incoming requests directly to the appropriate backend service based on port numbers. Please see src reverse_proxy nginx.conf Server Name Based Routing: This configuration allows Nginx to utilize different server names to route requests to the corresponding backend services. Please see src reverse_proxy nginx.example.conf If you wish to use the Server Name Based Routing configuration, you can rename the nginx.example.conf file to nginx.conf and modify it as needed or create your own configuration file and mount it to the Nginx container in the docker-compose.prod.yml file as shown below: reverse-proxy: container_name: reverse_proxy image: nginx:latest ports: - 80:80 - 8080:8080 - 3032:3032 - 3033:3033 volumes: - . reverse_proxy your_nginx.conf: etc nginx nginx.conf:ro depends_on: - backend - frontend_storefront - frontend_dashboard Please note that if you are using the Server Name Base Routing configuration, it’s good practice to remove port mapping from the Nginx container in the docker-compose.prod.yml file. The production environment can be started by running the following command in the src directory: docker compose -f docker-compose.prod.yml up -d Demo environment The demo environment in Ecoseller is designed to showcase the platform’s features and functionality using preloaded demo products (1400+), variants (2100+), and additional data. Setting up the demo environment is similar to the production environment, with the main difference being the utilization of the docker-compose.demo.yml file. It’s very similar to docker-compose.prod.yml but it has some additional services that are used to preload the demo data into the database. You can choose between using reverse proxy or accessing the services directly. However, it’s recommended to use the reverse proxy configuration for the demo environment as well (please see the Reverse Proxy section for more information as well ass Production environment). Our demo data live at public repository ecoseller demo-data The demo environment can be started by running the following command in the src directory: docker compose -f docker-compose.demo.yml up -d If you compare docker-compose.demo.yml and docker-compose.prod.yml, you can see that main difference is in the build target of backend service where demo is utilized. It means that there’re different scripts ran on startup, namely src backend demo_data_loader.sh which clones the repository and moves the data in propriate locations. git clone https: github.com ecoseller demo-data.git mv usr src demo-data media usr src mediafiles PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -U $POSTGRES_USER -d $POSTGRES_DB -p $POSTGRES_PORT -a -f usr src demo-data sql mock_data.sql Also, please note, that the demo environment is not intended for production use. It’s not setup for persistent storage so after you stop the containers all the data will be lost. Environment variables ecoseller utilizes environment variables to configure various aspects of the backend and recommendation system. These environment variables are stored in separate files, namely docker-compose.env. For the backend it’s src backend docker-compose.env and src recommender_system docker-compose.env for recommendation system. Additionally, the storefront, dashboard, and other services have their environment variables directly specified in the YAML file for specific docker compose. Backend This is an example of src backend docker-compose.env file. You can use it as a template for your own configuration. Please note that in this file you can configure Django backend and all the connections to other services that are used by the backend. You can find more information about Django environment variables in the official documentation. Example DEBUG=1 # 1 for development, 0 for production DJANGO_ALLOWED_HOSTS=\"*\" # for development only DATABASE=postgres DB_ENGINE=django.db.backends.postgresql_psycopg2 POSTGRES_DB=ecoseller POSTGRES_USER=postgres POSTGRES_PASSWORD=postgres POSTGRES_HOST=postgres_backend POSTGRES_PORT=5432 USING_REDIS_QUEUE=1 REDIS_QUEUE_LOCATION=redis PYTHONUNBUFFERED=1 RS_URL=\"http: recommender_system:8086\" STOREFRONT_URL=\"https: www.example.com\" NOTIFICATIONS_CONFIG_PATH=\". config notifications.json\" EMAIL_USE_SSL=1 EMAIL_PORT=465 EMAIL_HOST=smtp.example.com EMAIL_HOST_USER=ecoseller@example.com EMAIL_HOST_PASSWORD=\"yourpassword EMAIL_FROM=Storefront&lt;ecoseller@example.com&gt; USE_ELASTIC=1 ELASTIC_HOST=\"elasticsearch:9200\" ELASTIC_AUTO_REBUILD_INDEX=0 Recommendation system This is an example of src recommender_system docker-compose.env file. You can use it as a template for your own configuration, but please note that you need to change the RS_URL variable to match the URL in your ecoseller backend. Example RS_SERVER_HOST=0.0.0.0 RS_SERVER_PORT=8086 RS_SERVER_DEBUG=TRUE POSTGRES_PASSWORD=zZvyAvzG2O5gfr5 RS_PRODUCT_DB_URL=postgresql: postgres:zZvyAvzG2O5gfr5@postgres_rs:5432 products RS_FEEDBACK_DB_URL=postgresql: postgres:zZvyAvzG2O5gfr5@postgres_rs:5432 feedback RS_SIMILARITY_DB_URL=postgresql: postgres:zZvyAvzG2O5gfr5@postgres_rs:5432 similarity RS_MODEL_DB_URL=postgresql: postgres:zZvyAvzG2O5gfr5@postgres_rs:5432 model Reserved ports When running ecoseller, it is important to be aware of the reserved ports used by the various services within the platform. Reserved ports ensure that different components of ecoseller can communicate with each other effectively through Docker internal network. Here are the reserved ports used in ecoseller: Backend Service: The Ecoseller backend service runs on port 8000 by default. This is the primary entry point for accessing the backend APIs. PostgreSQL Backend: The Ecoseller backend PostgreSQL service is accessible on port 5433 by default. This is the primary entry point for accessing the backend PostgreSQL database. Backend Redis: The Ecoseller backend Redis service is accessible on port 6379 by default. This is the primary entry point for accessing the backend Redis database. Elasticsearch: The Elasticsearch service is accessible on port 9200 by default. This is the primary entry point for accessing the Elasticsearch database. Dashboard: The dashboard service is accessible on port 3030 by default. This is the primary entry point for accessing the dashboard. Storefront: The storefront service is accessible on port 3000 by default. This is the primary entry point for accessing the storefront. Recommendation system: The recommendation system service is accessible on port 8086 by default. This is the primary entry point for accessing the recommendation system. PostgreSQL Recommender system: The recommender PostgreSQL service is accessible on port 5432 by default. This is the primary entry point for accessing the recommender PostgreSQL database. When deploying ecoseller, make sure that the necessary ports are accessible and properly configured in your firewall settings or network infrastructure to allow incoming and outgoing traffic to the respective services if you don’t use proxy. By understanding and managing the reserved ports, you can ensure smooth communication and access to the different components of Ecoseller, enabling seamless functionality and integration within your e-commerce platform."
					}

					
				
			
		
			
				
					,
					

					"administration-localization": {
						"id": "administration-localization",
						"title": "Localization",
						"category": "",
						"url": " /administration/localization/",
						"content": "Table of contents: Languages Backend Storefront Country Currency VAT groups Ecoseller is designed to be a versatile and comprehensive e-commerce platform that caters to a global audience. With its aim to support multi-country operations, Ecoseller provides extensive localization capabilities across all aspects of user communication. This section of the administration documentation focuses on the localization features and configuration options available within Ecoseller. However, to understand the localization capabilities of Ecoseller, it is important to first understand the concept of locales and how they are used within the platform. We’ve chosen “country first” approach. Which means, that our main localize unit is a country. For example, if you want to have a store in the US and in the UK - you will have to create two countries, but mostlikely with the same language (English). But they will differ in currency, VAT groups, shipping methods and most likely even in the price list for products (since you might have different prices for stocking, packaging and marketing in different countries). Languages Since languages are loaded on the startup of the backend and storefront, when editing them, it’s neccessary to dive into the code a little bit. Backend Languages are loaded in the src backend core core settings.py file under the PARLER_LANGUAGES variable. If you want to add a new language, you will have to add a new entry to this variable, under the None key. If you want to set different language as a default, you will have to change the PARLER_DEFAULT_LANGUAGE_CODE variable in the same file as well as LANGUAGE_CODE. LANGUAGE_CODE = \"en\" PARLER_DEFAULT_LANGUAGE_CODE = \"en\" PARLER_LANGUAGES = { None: ( { \"code\": \"en\", }, { \"code\": \"cs\", }, ), \"default\": { \"fallbacks\": [\"en\"], # defaults to PARLER_DEFAULT_LANGUAGE_CODE \"hide_untranslated\": False, # the default; let .active_translations() return fallbacks too. }, } Backend languages are used for database translation - so for all data stored in the database, like product names, descriptions, categories, etc. and for the e-mails sent from the backend. If you want to edit translation of the e-mail templates, you will have to go to the container backend and run the following command: python3 manage.py makemessages -l en -l cs -l other_language ... After that, Django will create or append to the locale folder in the backend container. There you will find a folder for each language you’ve specified in the command above. In each folder, there will be a file called django.po. This file contains all the strings that are used in the backend and are marked for translation. You can edit the strings in this file and then run the following command to compile the changes: python3 manage.py compilemessages Editing data in the database is a little bit more complicated is fully handled by ecoseller dashboard. Everything is described in the user documentation. (TODO: add link to user documentation) Storefront Since storefront is a Next.js application, for the localization, we use next-i18next package. It’s a wrapper around i18next package, which is a very popular localization package for JavaScript. Languages are loaded in the src storefront next-i18next.config.js file under the i18n.locales variable (and i18n.defaultLocale). Translations are loaded in the src storefront public locales folder. Each language has its own folder and in each folder, there are multiple JSON files representing all i18n namespaces that can be found in the project. This file contains all the strings that are used in the storefront and are marked for translation. You can edit the strings in this file. After you’re done, you need to rebuild your container so that changes are applied. If you add new translations, then run npm run translate to extend the src storefront public locales folder with new namespaces and strings. Country Country is the main localization unit in ecoseller. It’s used to define the following: Currency VAT groups locale shipping methods Countries are stored in the database and can be edited in the ecoseller dashboard. Everything is described in the user documentation. (TODO: add link to user documentation) Currency Currency should allow you to make user more comfortable and feel like they’re shopping at their local store. Currency is binded to the country, so you can have different currencies for different countries. Currencies are also stored in the database and you can edit them in the ecoseller dashboard. Everything is described in the user documentation. (TODO: add link to user documentation) VAT groups VAT groups are used to define different VAT rates for different products and countries. With this feature, you can have different VAT rates for different countries as well as different VAT rates for different products (usually there’s a standard rate and reduced rate). VAT groups are also stored in the database and you can edit them in the ecoseller dashboard. Everything is described in the user documentation. (TODO: add link to user documentation)"
					}

					
				
			
		
			
				
					,
					

					"programming-backend": {
						"id": "programming-backend",
						"title": "Backend",
						"category": "",
						"url": " /programming/backend/",
						"content": "Table of contents: Data models Country Product Pricelist Currency CMS Cart User Authorization RolesManager Initial roles definitions and their loading Protecting views with permissions @check_user_access_decorator Parameters Usage example @check_user_is_staff_decorator Parameters Usage example Data models In this section we will describe data models of the backend part of the application. To do so, we will go over various parts of system and describe them in more detail using diagrams. To create diagrams, we used django-extensions app and its Graph models part, which generates a Graphviz .dot file from our django models. From that .dot file we used GraphvizOnline site to generate images of the diagrams. Country Above is the diagram of models with country specific data. The model is defined in backend core country models.py file. The main “building” block is a Country model which holds all the data related to countries - like name, code, language, pricelist and vat groups. VatGroup itself defines binding between country and VAT percentage. Currency looks like a separate model with no relations, but it’s mainly related to the PriceList model which will be described in a later sections. Address model is used to store addresses of users and is used during checkout process or are directly bindined to Cart model as well as User model. ShippingInfo and BillingInfo models are used to store user’s shipping and billing information during checkout process. They inherit from Address model and add some additional fields. Product Above is the diagram of models related to products and categories. The models are defined in backend core product models.py file and are divided into 2 groups: Product models - models that are directly related to products. They are: Product - main product model. ProductMedia - model for product media. It has a FK to Product model. ProductType - model for product types. It defines the type of product (e.g. t-shirts, coffee, etc.). It defines allowed AttributeTypes for product variants of this type and vat group for each country of this product. Category - model for product categories. It’s a tree structure, so it has a parent field which is a FK to itself. Product Variant models - models that are related to product variants. They are: ProductVariant - main product variant model. It has a FK to Product model. AttributeType - model for product variant attributes. It defines the type of attribute (e.g. color, size, etc.). BaseAttribute - model for product variant attribute values. It defines the value of attribute (e.g. red, blue, etc.). It has a FK to AttributeType model. Logic behind product variants is that each product variant has a set of attributes, which are defined by AttributeType model. Each attribute has a value, which is defined by BaseAttribute model. For example, if we have a product variant of type t-shirt, it will have 2 attributes: color and size. Each attribute will have a value, e.g. color will have values red, blue, green, etc. and size will have values S, M, L, etc. Pricelist Currency Above is the diagram of models related to price lists and currencies. The models are defined in backend core product models.py and backend core country models.py files. Every price (ProductPrice) represents a price of ProductVariant in a PriceList. Where PriceList usually represents a specific group of prices - it might be a group of prices for a specific country or a group of prices for a specific customers (like B2B or B2C). PriceList is also related to Currency model, which defines the currency of the prices in the price list. The interesting part of ecoseller pricing logic comes as VatGroup model which allows you to define different VAT groups for different countries. This allows you to have different VAT value (incl. different group of VAT - reduced, standard, …) for different countries. With this logic, you can define a price list for a specific country and define different VAT groups for different countries. This allows you to have different prices for different countries, which is a common practice in e-commerce (for example due to different expenses for marketing, stocking, etc.). CMS Above is the diagram of the CMS models with its main relations. Models are defined in backend core cms models.py file. It allows to create content pages with different types of content. The main model is PageCMS model, which represents a page with content in a specific language. It contains a content field in editorjs language. PageFrontend is an unussual idea in ecommerce platform. Since can have some specific pages that might not be stored in the database but would be represented as a HTML JSX page, PageFrontend is simply a link to that page - or, to be clear, path of that page in the frontend. Why do we need that? Imagine a situation where you simply want some extra CSS styles or some specific layout of the (landing) page. It’s made directly in the frontend app and you simply store link in the database. This is perfectly usefull if you consider other model PageCategory which basically puts a page in a category. This allows you to create a group of different PageCMS and PageFrontned. For example, you can create a category Info pages and put all your info pages in it. We can go a bit further and create PageCategoryType, which can group these categories. For example, you can create a PageCategoryType Footer and put all your categoreis that should display in footer. You can then fetch those footer specific categories and display them in the footer of your website. This is a very flexible way of creating content pages and displaying them in the frontend. Cart Above is the diagram of the Cart model with its main relations to other models. The model is defined in backend core cart models.py file. The Cart model is used to store user’s cart. It has a FK to User model, which binds the cart to the user. It also has a FK to ShippingMethodCountry and PaymentMethodCountry models, which are used to store user’s selected shipping and payment methods. We also have a CartItem model, which represents concrete item in the cart and has a FK relation to Cart. Each CartItem also has a FK to ProductVariant and Product models, to bind the item with the concrete product. The Cart model also has relations to country specific models such as Country, PriceList, PaymentMethodCountry and ShippingMethodCountry to ensure that the cart is bind to the concrete country specific data. Once the user creates an order, new relation is created - a FK from Order model to Cart. We can see one more model in the diagram - Review. It’s used to store user’s reviews of products. It has a FK to ProductVariant, Product and Order models. User Above is the diagram of the User model with its main relations to other models. The model is defined in backend core user models.py file. In ecoseller, we replaced default django User model with our own User model in order to have more control over it. You can see that it has 2 abstract models as its parents: AbstractBaseUser and PermissionsMixin: AbstractBaseUser is a django abstract model that provides basic user functionality PermissionsMixin is a django abstract model that provides permissions functionality. Another authorozation related models are Group and Permission models. They are django models that are used for authorization purposes. Group model is used to group users into units, while Permission model is used to define permissions for users. More on how we handle user authorization can be found in Authorization section. Next important relation is to Address model. It is used to store user’s address. As we can see, there is also a connection to ShippingInfo and BillingInfo, which are used during checkout process, to store user’s shipping and billing information. The last relation is to Cart model, which binds user to his cart. Authorization As mentioned in Authorization section, ecoseller uses roles and permissions to restrict access to certain parts of the application. To have better control over permissions representation and their grouping, we created 2 new models: ManagerPermission - for permission representation. It consists of: name - name of permission with predefined format: &lt;model_name&gt;_&lt;permission_type&gt;_permission. model - name of model to which this permission corresponds description - text description of permission type - type of permission. Enum of 4 possible values: view add change delete ManagerGroup - for group representation. It consists of: name - name of group description - text description of group permissions - M2M field to permissions of which this group consists. Each group permission should be convertable to DRF group permission. RolesManager RolesManager is our internal python class for handling permissions and (almost) everything related to them. It consists purely of static methods, so we can call them anywhere across the code. Its main usage is: Loading initial predefined roles from config and creating ManagerGroup and ManagerPermission objects from it Conversion between DRF Group and ManagerGroup, and also between DRF Permission and ManagerPermission Initial roles definitions and their loading As mentioned earlier, we have roles.json config file which has initial roles definition and RolesManager class which is responsible for loading it. We achieved this behaviour by following adjustments: We created initial_data.py file along with populate_groups method in it. In this method, we : load roles.json config with RolesManager class and create instances of ManagerGroup and ManagerPermission Create DRF Groups from loaded ManagerGroup objects Create general DRF permissions from app_config Convert all DRF permissions to ManagerPermission objects Assign ManagerPermission objects to corresponding ManagerGroup objects We put populate_groups method in our user migration file 0002_auto_20230316_1534.py to the operations part - this will ensure that when this migration runs, it will also trigger populate_groups method Protecting views with permissions In order to apply our permission restrictions, we defined two custom decorators are defined: @check_user_access_decorator and @check_user_is_staff_decorator (their definition can be found in backend core roles decorator.py). @check_user_access_decorator The decorator is used mainly for POST, PUT and DELETE views. It checks if the user has the permission to perform the action. If the user has the permission, the view is executed. Otherwise, the view returns 403 status code. Parameters permissions: Set of permissions that the user needs to have to access view Usage example To check whether the user has product_change_permission permission for accessing put method, put decorator above the method: @check_user_access_decorator({\"product_change_permission\"}) def put(self, request, id): return super().put(request, id) @check_user_is_staff_decorator The decorator is used mainly for GET views. It checks if the user is staff (is_staff field in User model). If the user is staff, the view is executed. Otherwise, the view returns 403 status code. Parameters None: The decorator does not take any parameters Usage example To check whether the user is staff for accessing get method, put decorator above the method: @check_user_is_staff_decorator() def get(self, request, id): return super().get(request, id)"
					}

					
				
			
		
			
				
					,
					

					"programming-dashboard-storefront": {
						"id": "programming-dashboard-storefront",
						"title": "Dashboard and Storefront",
						"category": "",
						"url": " /programming/dashboard_storefront/",
						"content": "Table of contents: Dashboard Storefront Context providers UserProvider Parameters Return value Usage example PermissionProvider Parameters Return value Usage example CartProvider Parameters Return value Functions provided by CartProvider addToCart removeFromCart updateQuantity clearCart cartProductQuantity Usage example CookieProvider Parameters Return value Functions provided by CookieProvider setCookieState setCookieSettingToCookies toggleDisclaimer Usage example CountryProvider Parameters Return value Functions provided by CountryProvider setCountryCookieAndLocale Usage example RecommenderProvider Dashboard Storefront Context providers To be able to access various data in different parts of the application, we use React Context. More information about React Context can be found on the following links: Passing data deeply with context useContext In further parts of this section, we assume that the reader is familiar with React Context and its usage from the links above. In ecoseller, we use various context providers, and now we will describe them in more detail. UserProvider UserProvider is a context provider that provides information about the currently logged in user to its children. It is used in both Dashboard and Storefront component, although they differ a bit in data they provide. Parameters children: React component that is wrapped by the provider Return value user: fetched data from user detail endpoint. Consists of: email - email of the user first_name - first name of the user last_name - last name of the user birth_date - birth date of the user is_active - whether the user is active is_admin - whether the user is admin is_staff - whether the user is staff roles: fetched data from roles user-groups ${email}. Consists of: name - name of the role description - description of the role permissions - list of permissions of the role. Each permission consists of: name - name of the permission description - description of the permission type - type of the permission model - model to which the permission corresponds UserProvider in Storefront only provides user data, while Dashboard provides both user and roles data. Usage example UserProvider already wraps whole application in both Dashboard and Storefront components, so we can access user data in any child component. To access user data, we use useUser hook: In dashboard: const ChildComponent = () =&gt; { ... const { user, roles } = useUser(); ... return ( ... ); }; In storefront: const ChildComponent = () =&gt; { ... const { user } = useUser(); ... return ( ... ); }; PermissionProvider As mentioned in Authorization section, ecoseller uses roles and permissions to restrict access to certain parts of the application. PermissionProvider is a context provider that provides information about user’s permissions to its children. It is used in Dashboard component. To ensure proper usage, we defined ContextPermissions type with permissions that may be passed to the provider. The type is defined in dashboard utils context permission.tsx file. Parameters allowedPermissions: Array of ContextPermissions - permissions the user needs to have to gain access to the component children: React component that is wrapped by the provider Return value hasPermission: boolean - true if the user has all permissions from allowedPermissions array, false otherwise Usage example To check whether the user has user_add_permission permission for adding new user, wrap the component with PermissionProvider: &lt;PermissionProvider allowedPermissions={[\"user_add_permission\"]}&gt; &lt;EditableContentWrapper&gt; &lt;CreateUser &gt; &lt; EditableContentWrapper&gt; &lt; PermissionProvider&gt; Now, we can check in respective component whether the user has the permission: const CreateUser () =&gt; { ... const { hasPermission } = usePermission(); ... return ( ... &lt;TextField disabled={!hasPermission} &gt; Email &lt; TextField&gt; ... ); }; const EditableContentWrapper = () =&gt; { ... const { hasPermission } = usePermission(); ... return ( ... &lt;Button disabled={!hasPermission} &gt; Save &lt; Button&gt; ... ); }; This will disable the TextField and Button components if the user does not have user_add_permission permission. CartProvider CartProvider is a context provider that provides information about the user’s cart as well as some usefull functions to its children. It is used only in Storefront component. Parameters children: React component that is wrapped by the provider Return value cart: fetched data from cart storefront &lt;str:token&gt; endpoint. Consists of: token - token of the cart cart_items - items of the cart update_at - date of the last update of the cart total_items_price_incl_vat_formatted - total price of the cart including VAT total_items_price_without_vat_formatted - total price of the cart without VAT total_price_incl_vat_formatted - total price of the cart including VAT and shipping total_price_without_vat_formatted - total price of the cart without VAT and shipping shipping_method_country - id to ShippingMethodCountry object payment_method_country - id to PaymentMethodCountry object cartSize: number of items in the cart addToCart - function for adding item to the cart removeFromCart - function for removing item from the cart updateQueantity - function for updating quantity of the item in the cart clearCart - function for clearing the cart cartProductQuantity - function for getting quantity of the product in the cart Functions provided by CartProvider addToCart Adds item to the cart. If the item is already in the cart, it updates its quantity. Takes following parameters: sku: SKU of the product qty: quantity of the product product: product ID pricelist: pricelist ID country: country ID removeFromCart Deletes item from the cart. Takes following parameters: sku: SKU of the product updateQuantity Updates quantity of the item in the cart. Takes following parameters: sku: SKU of the product quantity: new quantity of the product clearCart Clears the cart. Takes no parameters. cartProductQuantity Returns quantity of the product in the cart. Takes following parameters: sku: SKU of the product Usage example CartProvider already wraps whole application, so we can access data or functions in any child component. To do so, we use useCart hook: const ChildComponent = () =&gt; { ... const { cart, cartSize, addToCart, removeFromCart, updateQuantity, clearCart, cartProductQuantity } = useCart(); ... return ( ... ); }; CookieProvider CookieProvider is a context provider that provides information about the user’s cookies as well as some usefull functions to its children. It is used only in Storefront component. Parameters children: React component that is wrapped by the provider Return value cookieState - set consisting of set of boolean flags: neccessaryCookies - whether the user has accepted neccessary cookies preferenceCookies - whether the user has accepted preference cookies statisticalCookies - whether the user has accepted statistical cookies adsCookies - whether the user has accepted ads cookies openDisclaimer - whether to show cookie disclaimer setCookieState - function for setting cookie state setCookieSettingToCookies - function for setting cookie setting to cookies toggleDisclaimer - function for toggling cookie disclaimer Functions provided by CookieProvider setCookieState Sets cookie state. Takes following parameters: key: type of cookie value: boolean value to set to the cookie setCookieSettingToCookies Sets cookie setting to cookies. Takes following parameters: allTrue: whether all cookies are accepted toggleDisclaimer Toggles cookie disclaimer. Takes following parameters: value: whether to show cookie disclaimer Usage example CookieProvider already wraps whole application, so we can access data or functions in any child component. To do so, we use useCookie hook: const ChildComponent = () =&gt; { ... const { cookieState, setCookieState, setCookieSettingToCookies, toggleDisclaimer } = useCookie(); ... return ( ... ); }; CountryProvider CountryProvider is a context provider that provides information about the country that is currently set by the user, as well as some usefull functions to its children. It is used only in Storefront component. Parameters children: React component that is wrapped by the provider Return value country: object representing country. Consists of: code - id of the country name - name of the country locale - locale of the country default_price_list - id of the default price list of the country countryList: list of country objects - all available countries setCountryCookieAndLocale - function for setting country cookie and locale Functions provided by CountryProvider setCountryCookieAndLocale Sets country cookie and locale. Takes following parameters: countryCode: code of the country Usage example CountryProvider already wraps whole application, so we can access data or functions in any child component. To do so, we use useCountry hook: const ChildComponent = () =&gt; { ... const { country, countryList, setCountryCookieAndLocale } = useCountry(); ... return ( ... ); }; RecommenderProvider RecommenderProvider is a context provider that provides information about the user’s recommender session as well as some usefull functions to send either recommender event or retrive recommendations. It is used only in Storefront component."
					}

					
				
			
		
			
				
					,
					

					"programming-recommender-system": {
						"id": "programming-recommender-system",
						"title": "Recommender system",
						"category": "",
						"url": " /programming/recommender_system/",
						"content": "Table of contents:"
					}

					
				
			
		
			
				
					,
					

					"programming-supportive-services": {
						"id": "programming-supportive-services",
						"title": "Supportive services",
						"category": "",
						"url": " /programming/supportive_services/",
						"content": "Table of contents: ElasticSearch Redis PostgreSQL ElasticSearch Redis PostgreSQL"
					}

					
				
			
		
			
				
					,
					

					"programming-technical-design": {
						"id": "programming-technical-design",
						"title": "Technical design",
						"category": "",
						"url": " /programming/technical-design/",
						"content": "Table of contents: Architecture &amp; Design Backend written in Django: Core Application PostgreSQL Database: Storefront and Dashboard written in Next.js: Elasticsearch for Fast Product Search: Redis for Asynchronous Tasks via RQ-Worker: Recommender System written in Flask: Version control Coding style Links The technical design of the ecoseller system combines a robust backend written in Django, a PostgreSQL database for efficient data storage, and user-facing interfaces built with Next.js for the storefront and dashboard. Elasticsearch enhances product search capabilities, while Redis enables asynchronous task processing via RQ-Worker. Additionally, the Flask-based recommender system provides personalized product recommendations. This integrated architecture ensures a performant, and programmer-friendly e-commerce platform written in Python and TypeScript. Architecture &amp; Design The Ecoseller system is built upon an architecture incorporating various services and technologies to deliver a powerful e-commerce platform. This section provides an overview of the technical design of the ecoseller system, highlighting the key components and their interactions. Backend written in Django: The core of the ecoseller system is the backend, developed using the Django Rest Framework. Django provides a solid foundation for building web applications and offers a range of features such as user management, data modeling, and API development. The backend handles crucial functionalities like product management, order processing, user authentication, and more. We can divide the backend part into several subsections based on the area it handles. Core Application Core part of the application will be implemented in Python using the following technologies: Django Rest Framework – open source Python web framework Redis – open source data store that will help us with back-end task queuing Elasticsearch – search engine for storing and searching product data More technical details about the Core application can be found in the backend documentation. PostgreSQL Database: ecoseller utilizes a PostgreSQL database to store and manage data efficiently. PostgreSQL is a reliable and feature-rich open-source database that ensures data integrity, scalability, and performance for the platform. It handles critical data related to products, orders, user information, and various other entities within the system. The only system accessing this database is the backend described above. Storefront and Dashboard written in Next.js: The ecoseller platform includes two user-facing interfaces: the storefront and the dashboard. Both are developed using Next.js, a powerful React framework. Next.js enables the creation of dynamic, high-performance web applications with server-side rendering and optimized client-side navigation. The storefront serves as the online storefront for customers, while the dashboard provides a comprehensive administration panel for managing the e-commerce platform. Both applications are written in TypeScript and technical details can be found in the storefront &amp; dashboard documentation. Elasticsearch for Fast Product Search: ecoseller integrates Elasticsearch, a powerful search and analytics engine, to enhance the speed and accuracy of product searches. Elasticsearch enables efficient indexing, querying, and filtering of product data, ensuring a seamless and responsive search experience for users. The integration with Django allows for easy synchronization of product data between the backend and Elasticsearch. We use custom settings of Elasticsearch to improve the search experience. More on that in the section dedicated to supportive services. Redis for Asynchronous Tasks via RQ-Worker: ecoseller utilizes Redis, an in-memory data structure store, to support asynchronous task processing. The RQ (Redis Queue) library leverages Redis to manage and distribute tasks across workers. The RQ-Worker, an instance of the Ecoseller backend, processes tasks from the Redis queue, enabling efficient handling of background processes and time-consuming operations. More on that in the section dedicated to supportive services. Recommender System written in Flask: ecoseller incorporates a recommender system to provide personalized product recommendations to users. The recommender system is developed using Flask, a lightweight Python web framework. It leverages user behavior and preferences to generate relevant recommendations, enhancing the user experience and driving engagement. The recommender system is implemented in Python, the following technologies are used as well: Flask – open source Python web framework NumPy – open source Python library used to work with vectors and matrices TensorFlow – open source Python library used for machine learning The technical design of the ecoseller system seamlessly integrates these components, ensuring efficient data management, reliable operations, and a delightful user experience. By combining the power of Django, PostgreSQL, Next.js, Elasticsearch, Redis, and Flask, Ecoseller delivers a feature-rich and scalable e-commerce platform for businesses of all sizes with modern technologies. Version control As a version control system, current state-of the art git is used. More specifically GitHub. Coding style We use several tools for enforcing our code style. In both the dashboard and the storefront, we use: Prettier – an opinionated code formatter with support for many languages, including JavaScript and TypeScript ESLint – a static analysis tool identifying problematic patterns found in JavaScript and TypeScript code Similarly, in Core component (which is written in Python) we use black code formatter and flake8 linter. This way, we ensure consistent formatting of our code and avoid common bugs, which can be found by static analysis tools. We further use these tools in our Continuous integration setup, as described in Contribution - Continuous integration section. Links"
					}

					
				
			
		
			
				
					,
					

					"user-dashboard": {
						"id": "user-dashboard",
						"title": "User documentation - Dashboard",
						"category": "",
						"url": " /user/dashboard/",
						"content": "Table of contents: Overview Today’s statistics Statistics for the last 30 days Cart Orders Edit Order details Order items Status Shipping and billing info Shipping and payment method Reviews Review details Average product rating Catalog Localization CMS Users &amp; Roles Users User details Create user Roles Create role Edit role Recommender system Overview The Overview page provides summarised information about the store. It is the first page that is shown to the user after logging in. The page is divided into two main sections: Today’s statistics Statistics for the last 30 days Today’s statistics For today’s statistics, the following information is shown: Orders count Revenue Average order value Average items per order Top selling product Statistics for the last 30 days For the last 30 days’ statistics, the following information is shown: Orders count Revenue Average order value Average items per order Up to 5 top selling products Line graph showing orders count for the last 30 days Cart Orders The orders page consists of a list showing all orders. The list has the following columns: Order token Status Customer email Created at Actions The actions column contains the following buttons: Edit Edit Click on the edit button opens the order details page. Order details This page shows full information about the order. The page is divided into the following sections: Order items Status Shipping Info Billing info Shipping and payment methods Order items This section shows a list of all items in the order. The list has the following columns: Product variant name - click on the name opens the product variant details page (described in TODO: add link) SKU Quantity Unit price (without VAT) Actions Edit - admin can change the quantity of the product variant Delete - admin can delete the product variant from the order This section also shows the total price (without VAT) of a given order. Status This section shows the current status of the order. The status can be changed by the admin using a drop-down menu. Shipping and billing info This section shows the shipping and billing information of the order. It contains the same information as the shipping and billing information in the checkout process. Information is shown in the form view, and the admin is again able to modify its content. Shipping info Billing info Shipping and payment method This section shows selected shipping and payment methods along with their prices. TODO: add image Reviews The reviews page consists of a list showing all reviews. The list has the following columns: Review token Product variant Product ID Rating Comment Created at Actions Detail - click on the detail button opens the review details page (see below) Delete - click on the delete button deletes the review Review details This page shows full information about the review and overall rating of the product. The page is divided into the following sections: Rating - shown via stars and percentage Product ID Comment Average product rating Average product rating This section shows the average rating of the product. The rating is shown via start and average score (value from 0 to 5). It also shows the number of reviews for the product and the distribution of ratings. Distribution values are rounded up - this means that if the user submitted a rating of 4.5, it will be shown as 5 in the distribution. Catalog Localization CMS Users &amp; Roles This page provides an overview of all users and roles. It is into two main parts: Users Roles Users This section shows a list of all users. The list has the following columns: Email First name Last name Is Admin Roles Actions Edit - click on the edit button opens the user details page (see below) Delete - click on the delete button deletes the user User details The user details page shows full information about the user. The page is divided into three main parts: General information: Email (cannot be changed) First Name Last Name Is Admin - only admin can change this value Is Staff Password Old password - displayed only if a user is editing his profile New password New password confirmation Roles - a checklist of all roles available in the system. If a user has a role assigned, the checkbox is checked. Create user To create a new user, click on the Add New button in the users list. This opens a new page where the user can set the email and password. Roles Roles are used to group various permissions into one unit. This plays a crucial role in the authorization process as it restricts access to certain parts of the system. Only the admin or users with the user_change_permission permission can edit the user (for more detailed info about permissions see Authorization page). The system comes with three predefined roles: Editor Copywriter UserManager Admin counts as a special role that has all permissions. Authorized users can create new roles or edit existing ones. Create role To create a new role, click on the Add New button in the roles list. This opens a new page where the user can enter the name of the role, its description and select permissions that will be assigned to the role. Edit role To edit an existing role, click on the edit button in the roles list. This opens a new page where the user can edit a description of a given role and select permissions that will be assigned to the role. Recommender system"
					}

					
				
			
		
			
				
					,
					

					"user-storefront": {
						"id": "user-storefront",
						"title": "User documentation - Storefront",
						"category": "",
						"url": " /user/storefront/",
						"content": "Table of contents:"
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

		</article>
	</section>

	<script>
		document.getElementById("open-nav").addEventListener("click", function () {
			document.body.classList.toggle("nav-open");
		});
	</script>
</body>

</html>